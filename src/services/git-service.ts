import { includes, uniq } from "@banjoanton/utils";
import fs from "node:fs/promises";
import path from "node:path";
import sgf from "staged-git-files";
import { GIT_HOOKS } from "../constants";

import { isDevelopment } from "../runtime";
import type { FullConfig, GitHook } from "../types/types";
import { standout } from "../utils";
import { FileUtil } from "../utils/file-util";
import { ShellUtil } from "../utils/shell-util";
import { FeatureService } from "./feature-service";
import { LogService } from "./log-service";
import { PathService } from "./path-service";

export type GitStagedFiles = {
    filename: string;
    status: string;
};

const isGitHook = (hook: string | undefined): hook is GitHook => includes(GIT_HOOKS, hook);

const getRepoRoot = (() => {
    let cached: string | undefined;
    return async (): Promise<string> => {
        if (cached) return cached;
        const root = await PathService.getRootDirectory();
        if (!root) throw new Error("Could not find git repository root");
        cached = root;
        return root;
    };
})();

const getHooksPath = async (): Promise<string> => {
    const repoRoot = await getRepoRoot();
    return path.join(repoRoot, ".git/hooks");
};

const hookExists = async (hook: GitHook) => {
    const hooksPath = await getHooksPath();
    return FileUtil.pathExists(path.join(hooksPath, hook));
};

const getIncludeFilterLogic = (globs: string, runCommand: string): string =>
    `
globs="${globs}" 
grep_pattern=$(printf '^%s' "\${globs// /|^}")

should_run_hook() {
  local match=1
  while IFS= read -r file; do
    if echo "$file" | grep -Eq "$grep_pattern"; then
      match=0
      break
    fi
  done < <(git diff --cached --name-only)
  return $match
}

if should_run_hook; then
  ${runCommand}
else
  exit 0
fi
`.trim();

const hookTemplate = (hook: GitHook, config: FullConfig) => {
    const headerComment =
        "#!/bin/bash\n" +
        "# This file was automatically generated by hoks\n" +
        "# Do not edit this file manually\n";

    const runCommand = isDevelopment()
        ? `nr start --type ${hook} "$@"`
        : `export PATH="./node_modules/.bin:$PATH"
./node_modules/.bin/hoks --type ${hook} "$@"`;

    let body = runCommand;

    if (config.include && config.include.length > 0) {
        const globs = config.include.join(" ");
        body = getIncludeFilterLogic(globs, runCommand);
    }

    return [headerComment, body].join("\n");
};

const writeHook = async (hook: GitHook, config: FullConfig) => {
    const hooksPath = await getHooksPath();
    const hookFile = path.join(hooksPath, hook);
    await fs.writeFile(hookFile, hookTemplate(hook, config));
    await fs.chmod(hookFile, 0o755);

    LogService.success(`Successfully added ${standout(hook)} hook`);
};

const initializeHooks = async (config: FullConfig) => {
    LogService.debug("Initializing hoks");
    const features = FeatureService.getActiveFeatures(config);
    LogService.debug(`Found ${features.length} features`);

    const hooks = uniq(features.flatMap(feature => feature.hooks));
    LogService.debug(`Found ${hooks.length} hooks`);

    const hooksPath = await getHooksPath();
    const updatedPathAction = await ShellUtil.executeCommand({
        command: `git config core.hooksPath "${hooksPath}"`,
    });

    if (!updatedPathAction) {
        LogService.error("Failed to update git hooks path");
        process.exit(1);
    }

    LogService.debug(`Updated git hooks path to ${standout(hooksPath)}`);

    const hooksFolderExists = await FileUtil.pathExists(hooksPath);
    if (hooksFolderExists) {
        await fs.rm(hooksPath, { recursive: true });
    }
    await fs.mkdir(hooksPath, { recursive: true });

    LogService.debug("Updated hooks directory");

    const updated = [];
    for (const hook of hooks) {
        if (!isGitHook(hook)) {
            LogService.error(`Hook ${standout(hook)} is not a valid git hook`);
            continue;
        }

        await writeHook(hook, config);
        updated.push(hook);
    }

    const keys = Object.keys(config);
    const customHooks = keys.filter(key => includes(GIT_HOOKS, key));

    if (customHooks.length === 0) {
        LogService.debug("No custom hooks found");
        return;
    }

    LogService.debug(`Found ${customHooks.length} custom hooks in config`);

    for (const hook of customHooks) {
        if (updated.includes(hook)) {
            LogService.debug(`Custom hook ${standout(hook)} already exists`);
            continue;
        }

        await writeHook(hook as GitHook, config);
    }
};

type Status = "Added" | "Modified" | "Renamed" | "Deleted" | "Untracked";

const getStagedFiles = async (exclude: Status[] = ["Deleted"]): Promise<GitStagedFiles[]> => {
    const files = await sgf();

    return files.filter(file => !exclude.includes(file.status as Status));
};

const cleanHooks = async () => {
    LogService.debug("Cleaning hooks");
    const hooksPath = await getHooksPath();
    const hooks = await FileUtil.globby(path.join(hooksPath, "*"));
    for (const hook of hooks) {
        const content = await fs.readFile(hook, "utf8");
        if (!content.includes("hoks")) {
            LogService.debug(`Skipping ${hook}`);
            continue;
        }
        LogService.debug(`Removing ${hook}`);
        await fs.rm(hook);
    }

    LogService.debug("Successfully cleaned hooks");
};

export const GitService = {
    hookExists,
    hookTemplate,
    isGitHook,
    initializeHooks,
    getStagedFiles,
    cleanHooks,
    // Expose for testing/debugging
    _getRepoRoot: getRepoRoot,
    _getHooksPath: getHooksPath,
};
