/* eslint-disable no-empty */
import { includes, uniq } from "@banjoanton/utils";
import JSON5 from "json5";
import fs from "node:fs/promises";
import sgf from "staged-git-files";
import { Args } from "../cli";
import { EXAMPLE_CONFIG, GIT_HOOKS } from "../constants";
import { configTypeToConfigFile } from "../maps";
import { isDevelopment } from "../runtime";
import { Config, ConfigType, FullConfig, GitHook } from "../types/types";
import { executeCommand, standout } from "../utils";
import { FeatureService } from "./feature-service";
import { LogService } from "./log-service";

const isGitHook = (hook: string | undefined): hook is GitHook => {
    return includes(GIT_HOOKS, hook);
};

const fileExists = async (file: string) => {
    try {
        await fs.access(file);
        return true;
    } catch {
        return false;
    }
};

const hookExists = async (hook: GitHook) => await fileExists(`.git/hooks/${hook}`);

const hookTemplate = (hook: GitHook) => `#!/bin/sh
# This file was automatically generated by hoks
# Do not edit this file manually

${isDevelopment() ? "nr start" : "hoks"} --type ${hook} "$@"`;

const writeHook = async (hook: GitHook) => {
    await fs.writeFile(`.git/hooks/${hook}`, hookTemplate(hook));
    await fs.chmod(`.git/hooks/${hook}`, 0o755);

    LogService.success(`Successfully added ${standout(hook)}`);
};

const configFileExists = async (): Promise<ConfigType | null> => {
    if (await fileExists("hoks.config.js")) {
        return "js";
    }

    if (await fileExists("hoks.config.ts")) {
        return "ts";
    }

    if (await fileExists("hoks.config.json")) {
        return "json";
    }

    if (await fileExists("package.json")) {
        const pkg = await fs.readFile("package.json", "utf8");
        const pkgJson = JSON.parse(pkg);

        if (pkgJson.hoks) {
            return "package.json";
        }
    }

    return null;
};

const configExists = async (): Promise<ConfigType | null> => {
    const configFileType = await configFileExists();

    if (configFileType) {
        if (configFileType === "package.json") {
            LogService.debug("Config file already exists, type: package.json");
            return null;
        }
        LogService.debug(`Config file already exists, name: hoks.config.${configFileType}`);
        return null;
    }

    return configFileType;
};

const getConfigType = (args: Args): ConfigType => {
    const flags = args.flags;

    if (flags.javascript) {
        return "js";
    } else if (flags.package) {
        return "package.json";
    } else if (flags.json) {
        return "json";
    }

    return "ts";
};

const configCreator = async (
    configType: ConfigType,
    handler: (config: Config) => string
): Promise<ConfigType> => {
    LogService.debug(`Creating hoks config file for ${configType}`);
    const content = handler(EXAMPLE_CONFIG);
    const file = configTypeToConfigFile[configType];
    await fs.writeFile(file, content);
    return configType;
};

const createConfig = async (args: Args): Promise<ConfigType> => {
    const configType = getConfigType(args);

    switch (configType) {
        case "js": {
            return configCreator(
                configType,
                (config: Config) => `export default ${JSON5.stringify(config, null, 4)}`
            );
        }
        case "json": {
            return configCreator(configType, (config: Config) => JSON.stringify(config, null, 4));
        }
        case "package.json": {
            LogService.debug("Creating hoks config in package.json");
            const pkg = await fs.readFile("package.json", "utf8");

            const pkgJson = JSON.parse(pkg);

            pkgJson.hoks = EXAMPLE_CONFIG;

            await fs.writeFile("package.json", JSON.stringify(pkgJson, null, 4));
            LogService.debug(`Successfully created hoks config in package.json`);
            return configType;
        }

        default: {
            return configCreator(
                configType,
                (config: Config) =>
                    `import { defineConfig } from "${isDevelopment() ? "./src" : "hoks"}";
\nexport default defineConfig(${JSON5.stringify(config, null, 4)})`
            );
        }
    }
};

const init = async (config: FullConfig) => {
    LogService.debug("Initializing hoks");
    const features = FeatureService.getActiveFeatures(config);
    LogService.debug(`Found ${features.length} features`);

    const hooks = uniq(features.flatMap(feature => feature.hooks));
    LogService.debug(`Found ${hooks.length} hooks`);

    const updatedPathAction = await executeCommand("git config core.hooksPath .git/hooks/");

    if (updatedPathAction.exitCode !== 0) {
        LogService.error("Failed to update git hooks path");
        process.exit(1);
    }

    LogService.debug("Updated git hooks path");

    LogService.debug("Looking for existing hooks to remove");
    for (const hook of GIT_HOOKS) {
        if (await hookExists(hook)) {
            await fs.rm(`.git/hooks/${hook}`);
            LogService.debug(`Removed ${standout(hook)}`);
        }
    }

    const updated = [];
    for (const hook of hooks) {
        if (!isGitHook(hook)) {
            LogService.error(`Hook ${standout(hook)} is not a valid git hook`);
            continue;
        }

        await writeHook(hook);
        updated.push(hook);
    }

    const keys = Object.keys(config);
    const customHooks = keys.filter(key => includes(GIT_HOOKS, key));

    if (customHooks.length === 0) {
        LogService.debug("No custom hooks found");
        return;
    }

    LogService.debug(`Found ${customHooks.length} custom hooks in config`);

    for (const hook of customHooks) {
        if (updated.includes(hook)) {
            LogService.debug(`Custom hook ${standout(hook)} already exists`);
            continue;
        }

        await writeHook(hook as GitHook);
    }
};

const getStagedFiles = async () => {
    return await sgf();
};

export const GitService = {
    hookExists,
    isGitHook,
    init,
    getStagedFiles,
    createConfig,
    configExists,
};
